#define line 0
#define line_RW 200
#define line_LW 200
#define line_RL 50
#define line_ML 50
#define line_MR 40
#define line_LL 50

/*------Пины двигателей------*/
int E1 = 5;
int E2 = 6;
int M1 = 4;
int M2 = 7;
/*--------------------------*/


int leftLineSensor = 0;
int middleLineSensor = 0;
int rightLineSensor = 0;

int leftWaySensor = 0;
int frontWaySensor = 0;
int rightWaySensor = 0;


char leftWay[100];
char rightWay[100];
char frontWay[100];

int size = 0;

char direction = 'F';

int extraSpeed = 40; // 0...100

long previousMillis = 0; //for timer
long interval = 500;

void moveForward(float LEspeed, float REspeed)
{
  analogWrite (E1, LEspeed);
  digitalWrite (M1, HIGH);
  analogWrite (E2, REspeed);
  digitalWrite (M2, HIGH);
}

void moveBackward(float LEspeed, float REspeed)
{
  analogWrite (E1, LEspeed);
  digitalWrite (M1, LOW);
  analogWrite (E2, REspeed);
  digitalWrite (M2, LOW);
}

void turnLeft (float LEspeed, float REspeed)
{
  analogWrite (E1, LEspeed);
  digitalWrite (M1, LOW);
  analogWrite (E2, REspeed);
  digitalWrite (M2, HIGH);
}

void turnRight (float LEspeed, float REspeed)
{
  analogWrite (E1, LEspeed);
  digitalWrite (M1, HIGH);
  analogWrite (E2, REspeed);
  digitalWrite (M2, LOW);
}

void turnBack(float LEspeed, float REspeed)
{
  while (analogRead(3) > line_ML)
       turnLeft(LEspeed, REspeed);
}

char getLastWay()
{
  if (frontWay[size] == 'C')
      return 'F';
  if (leftWay[size] == 'C')
      return 'L';
  if (rightWay[size] == 'C')
      return 'R';
      
  if (frontWay[size] != 'C' && leftWay[size] != 'C' && rightWay[size] != 'C')
      return 'N';
}

void tryToCalibrate()
{
  if (analogRead(A5) < line_LW)
  {
      while (analogRead(A4) > line_LL)
          turnLeft(0, 130 + extraSpeed);
      delay(100);
  }
  
  if (analogRead(A4) < line_LL)
  {
      while (analogRead(3) > line_ML)
          turnLeft(0, 130 + extraSpeed);
      delay(100);
  }
  
  
  if (analogRead(A1) < line_RW)
  {
      while (analogRead(A2) > line_RL)
          turnRight(130 + extraSpeed, 0);
      delay(100);
  }
  if (analogRead(A2) < line_RL)
  {
      while (analogRead(A3) > line_MR)
          turnRight(130 + extraSpeed, 0);
      delay(100);
  }
          
  if (analogRead(A3) > line_MR && analogRead(3) > line_ML && analogRead(A4) > line_LL && analogRead(A2) > line_RL && digitalRead(10) != 0)
  {
    stop();
    delay(200);
    if (getLastWay() == 'L')
        while (digitalRead(10) != line)
            turnLeft(0, 130 + extraSpeed);
    if (getLastWay() == 'R')
        while (digitalRead(10) != line)
            turnRight(130 + extraSpeed, 0);
  }
}

void stop()
{
  digitalWrite(E1, LOW);
  digitalWrite(E2, LOW);
}



void setup() 
{
  Serial.begin(9600);
  tryToCalibrate();
}

void loop() 
{
  /*
  leftLineSensor = analogRead(A4);
  middleLeftSensor = analogRead(3);
  middleRightSensor = analogRead(A3);
  rightLineSensor = analogRead(A2);
  
  leftWaySensor = analogRead(A5);
  frontWaySensor = digitalRead(10);
  rightWaySensor = analogRead(A1);
  */
  
  //Serial.println(analogRead(A4));
  //A1 < 200
  //A2 < 50
  // 3 < 50
  //A3 < 40
  //A4 < 50
  //A5 < 200
  

  if (analogRead(A3) > line_MR && analogRead(3) > line_ML && analogRead(A4) > line_LL && analogRead(A2) > line_RL && analogRead(A1) > line_RW && analogRead(A5) > line_LW)
  {
    if (digitalRead(10) == 0)
        moveForward(130 + extraSpeed, 130 + extraSpeed);
    else
        if (digitalRead(2) == 0)
        { 
          stop();      // I don't want to fail here
          delay(2000); // Check!
          
          moveForward(130 + extraSpeed, 130 + extraSpeed); // Insurance
          delay(400);
          tryToCalibrate();
          
          if (digitalRead(2) == 0) // Is it real finnish? You're not kidding?
            {
              Serial.println("FINISH!"); //Oh, ok.
              direction = 'B';
              
              while(1)
                  stop();
            }
        }
  }
  
  if (analogRead(A4) < line_LL)
  {
      turnLeft(0, 130 + extraSpeed);
      delay(10);
  }
  if (analogRead(3) < line_ML)
  {
      moveForward(80 + extraSpeed, 130 + extraSpeed);
      delay(10);
  }
  if (analogRead(A3) < line_MR)
  {
      moveForward(130 + extraSpeed, 80 + extraSpeed);
      delay(10);
  }
  if (analogRead(A2) < line_RL)
  {
      turnRight(130 + extraSpeed, 0);
      delay(10);
  }
      
    
  if (analogRead(A1) < line_RW || analogRead(A5) < line_LW)
  {
    if (millis() - previousMillis > interval)
    {
      stop();
      delay(400);
      while(analogRead(A1) > line_RW && analogRead(A5) > line_LW) // проверка на "проскок"
          moveBackward(70 + extraSpeed, 70 + extraSpeed);
      stop();
    
      size++;
      digitalWrite(13, HIGH);
    
      
      if (digitalRead(10) == 0)
      {
        Serial.println('F');
        frontWay[size] = 'C';
      
        if (digitalRead(10) == 0)
            moveForward(130 + extraSpeed, 130 + extraSpeed);
        delay(400);
      }
    
      if (analogRead(A5) < line_LW && getLastWay() == 'N')
      {
        Serial.println('L');
        leftWay[size] = 'C';
      
        while (analogRead(A5) < line_LW)
            turnLeft(0, 130 + extraSpeed);
        while (analogRead(3) > line_ML)
            turnLeft(0, 130 + extraSpeed);
      }
      
      if (analogRead(A1) < line_RW && getLastWay() == 'N')
      {
        Serial.println('R');
        rightWay[size] = 'C';
      
        while (analogRead(A1) < line_RW)
            turnRight(130 + extraSpeed, 0);
        while (analogRead(A3) > line_MR)
            turnRight(130+extraSpeed, 0);
      }
    
      digitalWrite(13, LOW);
    
      tryToCalibrate();
    }
    else
        tryToCalibrate();
    
    previousMillis = millis();
 }
}
